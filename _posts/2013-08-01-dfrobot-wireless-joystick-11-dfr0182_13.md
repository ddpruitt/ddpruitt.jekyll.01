---
date: '2013-08-05T15:06:00.002-07:00'
description: ''
published: true
slug: 2013-08-dfrobot-wireless-joystick-11-dfr0182_13
tags:
- http://schemas.google.com/blogger/2008/kind#post
- Hardware
- Arduino
- legacy-blogger
time_to_read: 5
title: DFRobot Wireless Joystick 1.1 (DFR0182)
---

*This was originally posted on blogger [here](https://techshorts.blogspot.com/2013/08/dfrobot-wireless-joystick-11-dfr0182_13.html)*.

<a href="/wp-content/uploads/2013/08/DFR0182.jpg" target="_blank"><img alt="DFR0182" class="alignnone" height="294" src="https://dl.dropboxusercontent.com/u/480457/techshorts/2013/08/_d_improd_/DFR0182_f_improf_368x294.jpg" style="width: 367px; height: 294px;" title="DFRobot Gamepad" width="368" /></a><br /><br /><a href="./wp-content/uploads/2013/08/WirelessJoystick.zip">Wireless Joystick Sketch</a><br /><br /><a href="./wp-content/uploads/2013/08/Wireless-JoyStick-SCH.pdf">Wireless Joystick Schematic</a><br /><br /><a href="http://www.dfrobot.com/wiki/index.php?title=Wirless_Joystick_V1.1_(SKU:DFR0182)">DFRobot Wiki Page</a><br /><br />The DFRobot's Wireless Joystick V1.1 is similar in size and shape to an XBox controller.  The controller, or gamepad as it is also referred to, is an Arduino Deumilanove w/ATMega 328 and requires either an <a href="/wp-content/uploads/2013/08/DFR0182.jpg" target="_blank" title="FTDI">FTDI Basic Breakout</a> or <a href="/wp-content/uploads/2013/08/DFR0182.jpg" target="_blank" title="USB Serial Light">USB Serial Light Adapter</a> to program.  The board uses 3.3V, when connecting either the FTDI or USB Adapter verify correct voltage is set on the adapter, via jumpers on the adapter, otherwise you will burn out the gamepad.<br /><br /><a name="more"></a><br /><br /><a href="https://dl.dropboxusercontent.com/u/480457/techshorts/2013/08/USB_serial_light_adapter.jpg" target="_blank"><img alt="USB Serial Light Adapter" class="aligncenter" src="https://dl.dropboxusercontent.com/u/480457/techshorts/2013/08/USB_serial_light_adapter.jpg" title="USB Serial Light Adapter" /></a><br /><br />To program the Arduino you have to take the gamepad apart. Be careful not to loose the small screws and also be careful when you pull the gamepad apart. The buttons are not physically connected to the PCB and have a tendency to fall out. Also the PCB's power is supplied from the batteries in the bottom shell of the gamepad to the board via two small, short wires. Between the buttons falling out and the wires attached to the PCB programming the gamepad becomes a real chore fast. Oh, and the pins for the USB Serial Light / FTDI are on the bottom of the board so when you have adapter plugged in it is propping up the PCB.<br /><br />The board has an Xbee socket which supports Xbee, Bluetooth, RF and Wifi.  I used an <a href="https://www.sparkfun.com/products/8665" title="XBee 1mW S1">Xbee S1</a> with no problems. I used an <a href="https://www.sparkfun.com/products/8687" title="XBee Explorer USB">XBee Explorer USB</a> and <a href="http://www.digi.com/support/productdetail?pid=3352" title="X-CTU">X-CTU</a> to configure the XBee S1's.  One pain point I had was that since the Arduino only has one Serial I had to remove the Xbee whenever I wanted to program or monitor the Serial output of the gamepad.<br /><br />The gamepad comes with the following inputs:<br /><ul><br />	<li><span style="line-height: 16px;">2 analog triggers,</span></li><br />	<li>2 analog joysticks,</li><br />	<li>2 joystick buttons,</li><br />	<li>one D-Pad,</li><br />	<li>8 buttons,</li><br />	<li>1 reset buttons.</li><br /></ul><br /><a href="https://dl.dropboxusercontent.com/u/480457/techshorts/2013/08/DFR0182-Joystick.png" target="_blank"><img alt="PCB View" class="aligncenter" src="https://dl.dropboxusercontent.com/u/480457/techshorts/2013/08/DFR0182-Joystick.png" title="PCB View" /></a><br /><br />Finding detailed information on programming the gamepad was difficult, I was able to use a provided <a href="http://www.dfrobot.com/wiki/index.php?title=Wirless_Joystick_V1.1_(SKU:DFR0182)" target="_blank" title="wiki">example </a>sketch as a base for a more complete solution.<br /><br />I had originally wanted a NMEA type string but on the receiving end that would have been a lot of processing.  I finally opted for a simpler Key-Value pair, not quite a dictionary but close:<br /><br />[table caption="PhoNMEA" width="500" colalign="left|left|left"]<br />Key,Value,Description<br />$BTN:,button name,One of the 14 button names if the button was pressed.<br />$LTRG:,0 - 800,Left Trigger<br />$RTRG:,0 - 800,Right Trigger<br />$LJSY,-500 - 500,Left Joystick Y<br />$LJSX,-500 - 500,Left Joystick X<br />$RJSY,-500 - 500,Right Joystick Y<br />$RJSX,-500 - 500,Right Joystick X<br />[/table]<br /><br />One of the main issues I had was with calibration of the triggers and joysticks.  Normally the joystick X/Y values should range from 0 to 1023 and at dead center the value should be 512.  None of the joysticks centered at 512 and on one of them the X values didn't quite make it to 1023.  I measured all the center points and added a buffer range around the zero to ensure a zero value is returned.  After that liberal use of the constrain() and map() methods ensured acceptable ranges were returned by the gamepad.<br /><br />[c]<br />	void printJoySticks() {<br />	  Serial.print(&quot;$LJSY: &quot;), Serial.print(mapJoystickValue(joystick[0], leftJoyStickYMidPoint)), Serial.println(&quot;;&quot;);<br />	  Serial.print(&quot;$LJSX: &quot;), Serial.print(-1 * mapJoystickValue(joystick[1], leftJoyStickXMidPoint)), Serial.println(&quot;;&quot;);<br />	<br />	  Serial.print(&quot;$RJSY: &quot;), Serial.print(-1 * mapJoystickValue(joystick[2], rightJoyStickYMidPoint)), Serial.println(&quot;;&quot;);<br />	  Serial.print(&quot;$RJSX: &quot;), Serial.print(mapJoystickValue(joystick[3], rightJoyStickXMidPoint)), Serial.println(&quot;;&quot;);<br />	}<br /><br />	int mapJoystickValue(int value, int midPoint) {<br />	  int minRange, maxRange, adjustedValue;<br />	  minRange = midPoint - 10;<br />	  maxRange = midPoint + 10;<br />	<br />	  adjustedValue = value &gt; minRange &amp;&amp; value &lt; maxRange ? 510 : constrain(value, 0, 1020);<br />	  return map(adjustedValue, 0, 1020, -500, 500);<br />}<br /><br />[/c]<br /><br />[table caption="Button Names" width="500" colalign="left|left"]<br />Id, Name<br />X,X Button<br />Y,Y Button<br />A,A Button<br />B,B Button<br />WHITE,White Button<br />BLACK,Black Button<br />BACK,Back Button<br />START,Start Button<br />UP,D-Pad up<br />DOWN,D-Pad down<br />LEFT,D-Pad left<br />RIGHT,D-Pad right<br />LJS,Left Joystick Button<br />RJS,Right Joystick Button<br />[/table]<br /><br />When capturing the button states I compared the current state to the previous state.  If the button had been pressed during the last loop() then the buttons state is not re-transmitted to the Serial.  This prevents the button from being sent repeatedly to the receiver.<br /><br />[c]<br />	void printButtons(){<br />	  for(int i = 0; i &lt; 14; i++)  {<br />	    if(currButtonState[i] == 0 &amp;&amp; prevButtonState[i] != currButtonState[i])  {<br />	      Serial.print(&quot;$BTN: &quot;);<br />	      Serial.print(buttonName[i]);<br />	      Serial.println(&quot;;&quot;);<br />	    }<br />	    prevButtonState[i] = currButtonState[i];<br />	  }<br />	}<br />[/c]<br /><br />Enough talk, time for code:<br /><br />[c]<br />/*<br /> <br />  Editor     : Darren Pruitt<br />  Date       : 07.24.2013<br /><br />  Product name: Wireless Joystick v1.1 for Arduino<br />  Product SKU : DFR0182<br />  Arduino Duemilanove w/ ATmega328P<br />  Code Version: 1.0<br /><br />  Description:<br />  The sketch for using the gamepad by printing the button states and the analog values of the triggers and joysticks.<br /> <br />  Pin Mapping<br />  =======================<br />  D2:  X<br />  D3:  Y<br />  D5:  A<br />  D4:  B<br />  D6:  White<br />  D7:  Black<br />  D8:  UP<br />  D9:  LEFT:<br />  D10: DOWN<br />  D11: RIGHT<br />  D12: Back<br />  D13: Start<br /> <br />  X-A0,Y-A1: Left JOY<br />  D21: Left JOY_BUTTON<br /> <br />  X-A2,Y-A3: Right JOY<br />  D22: Right JOY_BUTTON<br /> <br />  A4: Left Z1<br />  A5: Right Z2<br /> <br />  RST : TURBO<br /> <br />*/<br /><br />// Gamepad Buttons<br />String buttonName[14] = {&quot;LJS&quot;,&quot;RJS&quot;,&quot;Y&quot;,&quot;X&quot;,&quot;B&quot;,&quot;A&quot;,&quot;WHITE&quot;,&quot;BLACK&quot;,&quot;UP&quot;,&quot;LEFT&quot;,&quot;DOWN&quot;,&quot;RIGHT&quot;,&quot;BACK&quot;,&quot;START&quot;};<br /><br />int triggerButton[2];<br />int currButtonState[14];<br />int prevButtonState[14];<br /><br />// Gamepad Joysticks<br />int joystick[4];<br /><br />int leftJoyStickXMidPoint, leftJoyStickYMidPoint, rightJoyStickXMidPoint, rightJoyStickYMidPoint;<br /><br />void setup()<br />{<br />  Serial.begin(9600);   //Init the Serial baudrate<br />  InitIO();             // Initialize the inputs/outputs and the buffers<br /> <br />  // These values taken from observations of the Joysticks while<br />  // they were centered.<br />  leftJoyStickXMidPoint = 500;<br />  leftJoyStickYMidPoint = 503;<br /><br />  rightJoyStickXMidPoint = 501;<br />  rightJoyStickYMidPoint = 495;<br />}<br /><br />void InitIO(){<br />  for(int i = 2; i &lt; 14; i++)  pinMode(i,INPUT);<br />  for(int i = 0; i &lt; 14; i++)  prevButtonState[i] = currButtonState[i] = 0;<br />  for(int i = 0; i &lt; 4; i++)   joystick[i] = 0;<br />  for(int i = 0; i &lt; 2; i++)   triggerButton[i] = 0;<br />}<br /><br />void loop()<br />{<br />  DataUpdate();<br /> <br />  printButtons();<br />  printJoySticks();<br />  printTriggers();<br /> <br />  delay(100);<br />}<br /><br />void DataUpdate(){<br /> <br />  for(int i = 2; i &lt; 14; i++)  currButtonState[i] = digitalRead(i);<br />  currButtonState[0] = analogRead(6);<br />  currButtonState[0] = currButtonState[0] &gt; 100 ? 1 : 0;<br /><br />  currButtonState[1] = analogRead(7);<br />  currButtonState[1] = currButtonState[1] &gt; 100 ? 1 : 0;<br /><br />  for(int i = 0; i &lt; 4; i++)  joystick[i] = analogRead(i);<br />  for(int i = 4; i &lt; 6; i++)  triggerButton[i-4] = analogRead(i);<br /> <br />}<br /><br />	void printButtons(){<br />	  for(int i = 0; i &lt; 14; i++)  {<br />	    if(currButtonState[i] == 0 &amp;&amp; prevButtonState[i] != currButtonState[i])  {<br />	      Serial.print(&quot;$BTN: &quot;);<br />	      Serial.print(buttonName[i]);<br />	      Serial.println(&quot;;&quot;);<br />	    }<br />	    prevButtonState[i] = currButtonState[i];<br />	  }<br />	}<br />	<br />	void printJoySticks() {<br />	  Serial.print(&quot;$LJSY: &quot;), Serial.print(mapJoystickValue(joystick[0], leftJoyStickYMidPoint)), Serial.println(&quot;;&quot;);<br />	  Serial.print(&quot;$LJSX: &quot;), Serial.print(-1 * mapJoystickValue(joystick[1], leftJoyStickXMidPoint)), Serial.println(&quot;;&quot;);<br />	<br />	  Serial.print(&quot;$RJSY: &quot;), Serial.print(-1 * mapJoystickValue(joystick[2], rightJoyStickYMidPoint)), Serial.println(&quot;;&quot;);<br />	  Serial.print(&quot;$RJSX: &quot;), Serial.print(mapJoystickValue(joystick[3], rightJoyStickXMidPoint)), Serial.println(&quot;;&quot;);<br />	}<br />	<br />	void printTriggers() {<br />	  Serial.print(&quot;$LTRG: &quot;);<br />	  Serial.print(map(constrain(triggerButton[0], 0, 800), 0, 800, 500, 0));<br />	  Serial.println(&quot;;&quot;);<br />	 <br />	  Serial.print(&quot;$RTRG: &quot;);<br />	  Serial.print(map(constrain(triggerButton[1], 0, 800), 0, 800, 500, 0));<br />	  Serial.println(&quot;;&quot;);<br />	}<br />	<br />	int mapJoystickValue(int value, int midPoint) {<br />	  int minRange, maxRange, adjustedValue;<br />	  minRange = midPoint - 10;<br />	  maxRange = midPoint + 10;<br />	<br />	  //adjustedValue = minRange &lt; value &lt; maxRange ? 510 : constrain(value, 0, 1020);;<br />	  adjustedValue = value &gt; minRange &amp;&amp; value &lt; maxRange ? 510 : constrain(value, 0, 1020);<br />	  return map(adjustedValue, 0, 1020, -500, 500);<br />}[/c]