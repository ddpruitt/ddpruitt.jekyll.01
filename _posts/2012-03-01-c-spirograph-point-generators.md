---
date: '2012-03-26T01:02:00.000-07:00'
description: ''
published: true
slug: 2012-03-c-spirograph-point-generators
tags:
- .Net
- graphic
- http://schemas.google.com/blogger/2008/kind#post
- Spirograph
- c#
- math
- legacy-blogger
time_to_read: 5
title: C# Spirograph Point Generators
---

*This was originally posted on blogger [here](https://techshorts.blogspot.com/2012/03/c-spirograph-point-generators.html)*.

<a href="http://en.wikipedia.org/wiki/Spirograph" title="Spirograph's">Spirograph's </a> are cool.  See <a href="http://www.math.psu.edu/dlittle/java/parametricequations/spirograph/SpiroGraph1.0/index.html" target="_blank" title="here">here</a> and <a href="http://www.math.psu.edu/dlittle/java/parametricequations/spirograph/index.html" target="_blank" title="here">here</a>.<br /><br /><img alt="" class="alignnone" height="247" src="http://upload.wikimedia.org/wikipedia/commons/9/90/Various_Spirograph_Designs.jpg" title="Various Spirograph Designs" width="345" /><br /><br />I put together three ways to generate points for a Spirograph, first using a Brute Force straight generate the points, second using a Parallel.For and third using LINQ.<br /><br /><a name="more"></a><br /><br />Two important classes first.  First is a static DoubleExtension class to help determine when two doubles are about equal:<br /><br />[csharp]<br />using System;<br /><br />namespace DC.SpiroGraph.Core<br />{<br />    public static class DoubleExtension<br />    {<br />        public static bool AboutEqual(double x, double y)<br />        {<br />            double epsilon = Math.Max(Math.Abs(x), Math.Abs(y)) * 1E-15;<br /><br />            var variance = x &gt; y ? x - y : y - x;<br />            return Math.Abs(variance)<br />         }<br />    }<br />}<br />[/csharp]<br /><br />Second, a simple Point class. Yeah, I probably could have used the Drawing Point class.<br /><br />[csharp]<br />using System;<br />using System.Diagnostics;<br /><br />namespace DC.SpiroGraph.Core<br />{<br />    [DebuggerDisplay(&quot;X = {X}, Y = {Y}&quot;)]<br />    public class Point<br />    {<br />        public double X { get; set; }<br />        public double Y { get; set; }<br /><br />        public bool NotAboutEqualTo(Point point)<br />        {<br />            return !DoubleExtension.AboutEqual(X, point.X) &amp;&amp; !DoubleExtension.AboutEqual(Y, point.Y);<br />        }<br />    }<br />}<br />[/csharp]<br /><br />Note the use of DebuggerDisplay to help with the debugging.<br />The SpiroGraphGenerator:<br /><br />[csharp]<br />using System;<br />using System.Collections.Generic;<br />using System.Linq;<br />using System.Threading.Tasks;<br /><br />namespace DC.SpiroGraph.Core<br />{<br />    public class SpiroGraphGenerator<br />    {<br />        /// &lt;summary&gt;<br />        /// Radius, R, of Circle (equator) centered at the origin<br />        /// &lt;/summary&gt;<br />        public double Radius1 { get; set; }<br /><br />        /// &lt;summary&gt;<br />        /// Radius, r, of circle (bicyle wheel) cetered at (R + r, 0)<br />        /// &lt;/summary&gt;<br />        public double Radius2 { get; set; }<br /><br />        /// &lt;summary&gt;<br />        /// Distance of Point (reflector) from the center of Circle 2 (the circle of Radius2)<br />        /// &lt;/summary&gt;<br />        public double Position { get; set; }<br /><br />        /// &lt;summary&gt;<br />        /// Controls how precise the SpiroGraph is drawn.<br />        /// Controls t of f(t).<br />        /// Resolution = 360, t = 0, 1, 2, 3, ...,360<br />        /// Resolution = 180, t = 0, 2, 4, 6, ... 360<br />        /// <br />        /// &lt;/summary&gt;<br />        public double Resolution { get; set; }<br /><br />        public IEnumerable&lt;Point&gt;  GetSpiroGraphPoints()<br />        {<br /><br />            var t = 0d;<br />            var sumOfRadius = Radius1 + Radius2;<br /><br />            var firstPoint = new Point { X = Xt(sumOfRadius, Radius2, Position, t), Y = Yt(sumOfRadius, Radius2, Position, t) };<br />            var currentPoint = new Point { X = firstPoint.X, Y = firstPoint.Y };<br /><br />            // Convert to Radians<br />            var increment = (360 / Resolution) * Math.PI / 180;<br /><br />            do<br />            {<br />                for (var i = 0; i &lt; Resolution; i++)<br />                {<br />                    yield return currentPoint;<br />                    t += increment;<br />                    currentPoint = new Point { X = Xt(sumOfRadius, Radius2, Position, t), Y = Yt(sumOfRadius, Radius2, Position, t) };<br />                }<br />            } while (currentPoint.NotAboutEqualTo(firstPoint));<br />            <br />            yield return currentPoint;<br />        }<br /><br />        public IEnumerable&lt;Point&gt; GetSpiroGraphPoints2()<br />        {<br />            var endPoints = FindAllEndPoints();<br />            var numberOfEndPonits = endPoints.Count();<br />            var numberOfPoints = Convert.ToInt32((numberOfEndPonits - 1)*Resolution + 1);<br />            var points = new Point[numberOfPoints];<br />            var resolution = Convert.ToInt32(Resolution);<br /><br />            var sumOfRadius = Radius1 + Radius2;<br /><br />            // Convert to Radians<br />            var increment = (360/Resolution)*Math.PI/180;<br />            points[0] = GetPoint(sumOfRadius, 0);<br /><br />            Parallel.For(1, numberOfEndPonits, i =&gt;<br />			   {<br />				   for (var j = 0; j &lt; resolution; j++)<br />				   {<br />					   var pointIndex = (i - 1)*resolution + j + 1;<br />					   var t = pointIndex*increment;<br />					   points[pointIndex] = GetPoint(sumOfRadius, t);<br />				   }<br />			   });<br />            return points;<br />        }<br />        <br />        public IEnumerable&lt;Point&gt; GetSpiroGraphPoints3()<br />        {<br />            var endPoints = FindAllEndPoints();<br />            var numberOfEndPonits = endPoints.Count();<br />            var numberOfPoints = Convert.ToInt32((numberOfEndPonits - 1)*Resolution + 1);<br /><br />            var sumOfRadius = Radius1 + Radius2;<br /><br />            // Convert to Radians<br />            var increment = (360/Resolution)*Math.PI/180;<br /><br />            var points2 = Enumerable.Range(0, numberOfPoints)<br />                .Select(i =&gt; new {Index = i, t = i*increment})<br />                .Select(it =&gt; new {it.Index, point = GetPoint(sumOfRadius, it.t)})<br />                .OrderBy(ip =&gt; ip.Index)<br />                .Select(ip =&gt; ip.point);<br /><br />            return points2;<br />        }<br /><br />        public IEnumerable&lt;Point&gt; FindAllEndPoints()<br />        {<br />            var t = 0d;<br />            var sumOfRadius = CalculateSumOfRadius();<br /><br />            var firstPoint = GetPoint(sumOfRadius, t);<br />            var currentPoint = new Point { X = firstPoint.X, Y = firstPoint.Y };<br />            // Convert to Radians<br />            var increment = CalculateIncrement();<br /><br />            do<br />            {<br />                yield return currentPoint;<br />                t += (increment*Resolution);<br />                currentPoint = GetPoint(sumOfRadius, t);<br />            } while (currentPoint.NotAboutEqualTo(firstPoint));<br /><br />            yield return currentPoint;<br />        }<br /><br />        private double CalculateIncrement()<br />        {<br />            return (360/Resolution)*Math.PI/180;<br />        }<br /><br />        private double CalculateSumOfRadius()<br />        {<br />            return Radius1 + Radius2;<br />        }<br /><br />        private static double Xt(double sumOfRadius, double radius2, double position , double t)<br />        {<br />            return sumOfRadius * Math.Cos(t) + position * Math.Cos(sumOfRadius * t / radius2);<br />        }<br /><br />        private static double Yt(double sumOfRadius, double radius2, double position, double t)<br />        {<br />            return sumOfRadius * Math.Sin(t) + position * Math.Sin(sumOfRadius * t / radius2);<br />        }<br /><br />        private Point GetPoint(double sumOfRadius, double t)<br />        {<br />            return new Point { X = Xt(sumOfRadius, Radius2, Position, t), Y = Yt(sumOfRadius, Radius2, Position, t) };<br />        }<br />    }<br />}<br />[/csharp]<br /><br />I created a simple WinForm app using DevExpress controls, this is how I populated the graph with points:<br /><br />[csharp highlight="28,31"]<br />using System;<br />using System.Linq;<br />using System.Windows.Forms;<br /><br />namespace DC.SpiroGraph.WinForm<br />{<br />    public partial class Form1 : Form<br />    {<br />        public Form1()<br />        {<br />            InitializeComponent();<br />        }<br /><br />        public void CreateData(bool useParallel)<br />        {<br />            try<br />            {<br />                Cursor.Current = Cursors.WaitCursor;<br /><br />                var sg = new Core.SpiroGraphGenerator<br />                {<br />                    Radius1 = Convert.ToDouble(radius1TextEdit.Text),<br />                    Radius2 = Convert.ToDouble(radius2TextEdit.Text),<br />                    Position = Convert.ToDouble(positionTextEdit.Text),<br />                    Resolution = Convert.ToDouble(resolutionTextEdit.Text)<br />                };<br /><br />                var endPoints = sg.FindAllEndPoints();<br />                endPointCountLabel.Text = string.Format(&quot;# of End Points: {0}&quot;, endPoints.Count());<br /><br />                var graphPoints = useParallel?  sg.GetSpiroGraphPoints2() : sg.GetSpiroGraphPoints3();<br />                pointCountLabel.Text = string.Format(&quot;# of Points: {0}&quot;, graphPoints.Count());<br /><br />                chartControl1.Series[0].DataSource = graphPoints;<br /><br />            }<br />            catch (Exception)<br />            {<br /><br />                // Eat It<br />            }<br />            finally<br />            {<br />                Cursor.Current = Cursors.Default;<br />            }<br />        }<br /><br />        private void Form1_Load(object sender, EventArgs e)<br />        {<br />            var series = chartControl1.Series[0];<br />            series.Label.Visible = false;<br />            series.ArgumentDataMember = &quot;X&quot;;<br />            series.ValueDataMembers.AddRange(new string[] {&quot;Y&quot;});<br /><br />            radius1TextEdit.Text = &quot;60&quot;;<br />            radius2TextEdit.Text = &quot;60&quot;;<br />            positionTextEdit.Text = &quot;60&quot;;<br />            resolutionTextEdit.Text = &quot;270&quot;;<br /><br />            CreateData(true);<br />        }<br /><br />        private void simpleButton1_Click(object sender, EventArgs e)<br />        {<br />            CreateData(true);<br />        }<br /><br />        private void simpleButton2_Click(object sender, EventArgs e)<br />        {<br />            CreateData(false);<br />        }<br />    }<br />}<br />[/csharp]<br /><br />Future changes will be to make a series for each rotation about the main circle, this way we can start adding different colors to the graph.