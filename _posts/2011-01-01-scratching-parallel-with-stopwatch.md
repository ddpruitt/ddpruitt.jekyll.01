---
date: '2011-01-18T00:54:00.000-08:00'
description: ''
published: true
slug: 2011-01-scratching-parallel-with-stopwatch
tags:
- .Net
- http://schemas.google.com/blogger/2008/kind#post
- legacy-blogger
time_to_read: 5
title: Scratching Parallel with StopWatch
---

*This was originally posted on blogger [here](https://techshorts.blogspot.com/2011/01/scratching-parallel-with-stopwatch.html)*.

Threw together a quick parallel stopwatch test.  Not sure if the times prove anything.<br /><br />[csharp highlight="28,33,39"]<br />using System;<br />using System.Collections.Generic;<br />using System.Diagnostics;<br />using System.Linq;<br />using System.Threading.Tasks;<br /><br />namespace Scratch.ParallelProcessing<br />{<br />    class Program<br />    {<br />        static void Main(string[] args)<br />        {<br />            const int count = 10000000;<br />            var source1 = Enumerable.Range(0, count).ToArray();<br />            var source2 = Enumerable.Range(0, count).ToArray();<br />            var source3 = Enumerable.Range(0, count).ToArray();<br /><br />            Stopwatch stopwatch = new Stopwatch();<br /><br />            var parallelElapsedTimes = new List&lt;TimeSpan&gt;();<br />            var linearElapsedTimes = new List&lt;TimeSpan&gt;();<br />            var linqSelectElapsedTimes = new List&lt;TimeSpan&gt;();<br /><br />            for (int i = 0; i &lt; 10; i++)<br />            {<br />                stopwatch.Reset();<br />                stopwatch.Start();<br />                var parallelResults = Parallel.ForEach(source1, s =&gt; s %= 2);<br />                parallelElapsedTimes.Add(stopwatch.Elapsed);<br />                stopwatch.Reset();<br />                <br />                stopwatch.Start();<br />                LinearAction(source2, s =&gt; s %= 2);<br />                linearElapsedTimes.Add(stopwatch.Elapsed);<br />                stopwatch.Reset();<br /><br />                stopwatch.Reset();<br />                stopwatch.Start();<br />                Array.ForEach(source3, s=&gt;s = s%2);<br />                linqSelectElapsedTimes.Add(stopwatch.Elapsed);<br />                stopwatch.Reset();<br />                <br />            }<br /><br />            Console.WriteLine(&quot;Elapsed Time\t\tMin\t\tMax\t\t\tAvg&quot;);<br />            Console.WriteLine(&quot;============\t\t===\t\t===\t\t\t===&quot;);<br />            Console.WriteLine(&quot;{0}\t\t{1}\t\t{2}\t\t\t{3}&quot;, &quot;Parallel&quot;, parallelElapsedTimes.Min(t =&gt; t.Milliseconds), parallelElapsedTimes.Max(t =&gt; t.Milliseconds), parallelElapsedTimes.Average(t =&gt; t.Milliseconds));<br />            Console.WriteLine(&quot;{0}\t\t\t{1}\t\t{2}\t\t\t{3}&quot;, &quot;Linear&quot;, linearElapsedTimes.Min(t =&gt; t.Milliseconds), linearElapsedTimes.Max(t =&gt; t.Milliseconds), linearElapsedTimes.Average(t =&gt; t.Milliseconds));<br />            Console.WriteLine(&quot;{0}\t\t\t{1}\t\t{2}\t\t\t{3}&quot;, &quot;Linq&quot;, linqSelectElapsedTimes.Min(t =&gt; t.Milliseconds), linqSelectElapsedTimes.Max(t =&gt; t.Milliseconds), linqSelectElapsedTimes.Average(t =&gt; t.Milliseconds));<br /><br />        }<br /><br />        public static void LinearAction&lt;T&gt;(IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)<br />        {<br />            foreach (var s in source) action(s);<br />        }<br />    }<br />}<br /><br /><br />[/csharp]<br /><br />Results of the timer:<br /><code><br />Elapsed Time            Min             Max                     Avg<br />============            ===             ===                     ===<br />Parallel                63              191                     79.5<br />Linear                  138             143                     140.3<br />Linq                    54              56                      54.5<br />Press any key to continue . . .<br /></code><br /><br />I'm running 64 bit Vista on a Intel Core2 Duo with 4GB RAM.  The Parallel seems to be inconsistent, and depends a lot on whether or not it grabs that second CPU.